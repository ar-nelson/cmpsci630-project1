%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                      %
%  AUTOGENERATED FROM project-writeup.md USING PANDOC  %
%                                                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Adam Nelson (some test cases and early code written by Arpita Raveendran)},
            pdftitle={CMPSCI 630 Python Interpreter},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{5}

\title{CMPSCI 630 Python Interpreter}
\author{Adam Nelson (some test cases and early code written by Arpita
Raveendran)}
\date{October 26, 2014}

\begin{document}
\maketitle

\section{Project Description}\label{project-description}

This is an interpreter for a limited subset of Python 2.7.\emph{x}
bytecode (\texttt{.pyc} files), written as an HTML5+TypeScript web
application.

\subsection{Compiling and Running the
Project}\label{compiling-and-running-the-project}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Install \href{http://nodejs.org}{node.js} and
  \href{http://npmjs.org}{npm}.
\item
  Install TypeScript:

\begin{verbatim}
> npm install -g typescript
\end{verbatim}
\item
  Navigate to the project directory, and compile the TypeScript files:

\begin{verbatim}
> tsc @files.txt
\end{verbatim}
\item
  Open \texttt{index.html} in any modern browser (supports IE \(\ge 10\)
  and the latest Firefox/Chrome).
\end{enumerate}

\subsection{Using the Interpreter UI}\label{using-the-interpreter-ui}

The HTML5 UI is split into two panes. The right-side pane lists included
test cases and provides a field for uploading \texttt{.pyc} files, and
the left-side pane provides two tabs for output: the ``Output'' tab
displays the interpreter's console output, while the ``Bytecode'' tab
displays the bytecode of the \texttt{.pyc} file in a human-readable
format. Clicking a test case filename or uploading a \texttt{.pyc} file
will cause the interpreter to parse and execute the file.

The interpreter supports the \texttt{raw\_input} builtin function, and
may request user input via an HTML
\texttt{\textless{}input type="text"\textgreater{}} control displayed in
the ``Output'' tab. The only test case that demonstrates this feature is
\texttt{functions.pyc}.

Test cases are in the \texttt{pyc/} subdirectory of the project
directory. All test cases are provided as both \texttt{.py} source files
and \texttt{.pyc} binary files; to validate the output of the test
cases, compare the ``Output'' tab of the UI with the ouput generated by
executing the same test case's \texttt{.py} file in \texttt{python}.

\section{Implementation Details}\label{implementation-details}

\subsection{The Bytecode Parser}\label{the-bytecode-parser}

The \texttt{Python.Bin} module, contained in \texttt{bytecode.ts} and
\texttt{pyc-parser.ts}, implements a Python 2.7.\emph{x} bytecode
parser. \texttt{bytecode.ts} specifies all of the opcodes, magic
numbers, and data structures in marshalled Python code, and is
thoroughly commented, including documentation from
\href{https://docs.python.org/2/library/dis.html}{Python's \texttt{dis}
module} and
\href{http://daeken.com/2010-02-20_Python_Marshal_Format.html}{this page
on Python marshalled types}.

A \texttt{Python.Bin.Parser} reads binary data from an JavaScript
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView}{DataView}
object and converts it to a single marshalled \emph{code object}
(\texttt{Python.Bin.CodeObject}), which itself contains several other
marshalled data objects (\texttt{Python.Bin.Object}). If the parser
executes without error, a human-readable representation of the
marshalled code object will be printed to the ``Bytecode'' tab in the
left pane of the UI.

All Python 2.7.\emph{x} opcodes are documented and can be printed,
although not all of them are implemented in the interpreter. Most of
Python's marshalled data types are supported, but the \texttt{INT64},
\texttt{LONG}, and \texttt{UNICODE} types are not; attempting to load a
\texttt{.pyc} file containing one of these data types will cause a
parser error.

After parsing, the marshalled objects will be converted to ``live''
Python objects (\texttt{Python.PyObject}) via the unmarshaller
(\texttt{unmarshaller.ts}).

\subsection{The PyObject Hierarchy}\label{the-pyobject-hierarchy}

All objects in the Python interpreter are instances of the
\texttt{Python.PyObject} interface, which is loosely based on
\href{https://docs.python.org/2/c-api/object.html}{the \texttt{PyObject}
protocol} in \href{https://docs.python.org/2/c-api/}{Python's C API}.

The interpreter uses a pure-object-oriented approach: everything is a
\texttt{PyObject}, and every operation is a method---even primitive
operations like basic math. This OO approach is strictly based on
\href{https://docs.python.org/2/reference/datamodel.html}{Python's data
model}. Only a few special cases (\texttt{\_\_repr\_\_} and
\texttt{\_\_str\_\_} for strings, \texttt{\_\_call\_\_} for functions)
are implemented in a way that isn't accessible as a method call, and
this was only done to avoid infinite recursion. Several basic,
commonly-used methods on primitive types (including most operators) were
implemented, but many have been omitted; an exhaustive implementation of
Python's standard library is beyond the scope of this project.

Every \texttt{PyObject} has a type (\texttt{Python.PyTypeObject}), even
type objects themselves, whose type is \texttt{Python.Types.TypeType}.
Every type has a \texttt{\_\_dict\_\_}, which contains methods that can
be called on instances of the type, either directly with a \texttt{self}
argument (via \texttt{PyObject.callMethod()}), or by getting the method
object as an attribute of an instance, then calling it with a normal
argument list. Function calls support \texttt{*args}, \texttt{**kwargs},
and named arguments, although built-in methods only support fixed
argument counts.

The interpreter does not support user-defined classes, but it defines
the following built-in types in the following files:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{PyObject.ts}: \texttt{object}, \texttt{type},
  \texttt{dictproxy}, \texttt{method\_descriptor},
  \texttt{builtin\_function\_or\_method}
\item
  \texttt{PyNumbers.ts}: \texttt{int}, \texttt{bool}, \texttt{float},
  \texttt{complex}
\item
  \texttt{PyConstants.ts}: \texttt{None}, \texttt{Ellipsis},
  \texttt{NotImplemented}
\item
  \texttt{PyString.ts}: \texttt{str}
\item
  \texttt{PySequences.ts}: \texttt{tuple}, \texttt{list}, \texttt{set},
  \texttt{frozenset}
\item
  \texttt{PyDict.ts}: \texttt{dict}
\item
  \texttt{PyCodeObject.ts}: \texttt{code}, \texttt{function}
\item
  \texttt{PyExceptions.ts}: Most of the
  \href{https://docs.python.org/2/library/exceptions.html}{built-in
  exception types}
\end{itemize}

\subsection{The Interpreter}\label{the-interpreter}

The interpreter (\texttt{interpreter.ts}) attempts to model the CPython
interpreter as closely as possible. It is a stack machine, with three
stacks:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  The \emph{local stack}, which contains variables being used in the
  current block.
\item
  The \emph{block stack}, which contains blocks (loops,
  \texttt{try}/\texttt{except}/\texttt{finally}), each of which has its
  own local stack. \texttt{break}, \texttt{continue}, \texttt{return},
  and exceptions may cause the interpreter to unwind this stack, pausing
  at any \texttt{finally} blocks to perform cleanup.
\item
  The \emph{code stack}, which contains code objects; a new code object
  is pushed whenever a function is called, and popped when a function
  returns. Each code object has its own block stack.
\end{itemize}

It supports only a limited subset of Python 2.7.\emph{x} opcodes; the
missing opcodes include, but are not limited to:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{DUP\_TOPX}
\item
  \texttt{UNPACK\_SEQUENCE}
\item
  \texttt{YIELD\_VALUE}
\item
  \texttt{RAISE\_VARARGS}
\item
  \texttt{MAKE\_CLOSURE} and \texttt{LOAD\_CLOSURE} (because of this,
  functions that reference variables outside their own scopes don't
  work)
\item
  Anything related to imports
\item
  Anything related to the \texttt{with} statement
\item
  \texttt{BUILD\_CLASS} and a few other opcodes used for class creation
\item
  The special print opcodes \texttt{PRINT\_EXPR},
  \texttt{PRINT\_ITEM\_TO}, and \texttt{PRINT\_NEWLINE\_TO}
\item
  The special call opcodes \texttt{CALL\_FUNCTION\_VAR},
  \texttt{CALL\_FUNCTION\_KW}, and \texttt{CALL\_FUNCTION\_VAR\_KW}
\end{itemize}

Although most of the interpreter's functionality could be derived from
documentation alone, I ended up needing to reference
\href{https://github.com/python-git/python/blob/master/Python/ceval.c}{the
CPython source code} to determine exactly how exceptions and
\texttt{END\_FINALLY} worked; the \texttt{dis} documentation for this is
\href{https://docs.python.org/2/library/dis.html\#opcode-END_FINALLY}{not
exactly comprehensive}. Raising an exception pushes three objects onto
the stack (exception, message, traceback), and entering a
\texttt{finally} block will either push these three objects (if an
exception caused the stack to unwind) or an integer called a
``\texttt{WHY} value'' (if something else cause the stack to unwind).
\texttt{END\_FINALLY} may consume either 1 or 3 objects from the stack
depending on what it encounters. \emph{None of this is documented.}
Ultimately, I implemented \texttt{finally} blocks somewhat differently
from CPython: \texttt{finally} recursively calls
\texttt{Interpreter.exec()}, which returns when it encounters
\texttt{END\_FINALLY}, ignoring a \texttt{WHY} value if one exists.

\section{Results and Observations}\label{results-and-observations}

The interpreter manages to run a limited set of test cases with perfect
accuracy. It undoubtedly still has some bugs; I didn't test it as
thoroughly as I would have liked to.

I would have liked to include imports, classes, closures, and perhaps
some standard library files, but there wasn't time. Even with its
limited scope, support for numbers, strings, collections, flow control,
exceptions, \texttt{print}, and \texttt{raw\_input} is enough for this
interpreter to run useful programs. With some work, this could easily
become a full implementation of Python in the browser.

\end{document}
