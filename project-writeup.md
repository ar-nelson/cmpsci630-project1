% CMPSCI 630 Python Interpreter
% Adam Nelson (some test cases and early code written by Arpita Raveendran)
% October 26, 2014

# Project Description

This is an interpreter for a limited subset of Python 2.7._x_ bytecode (`.pyc` files), written as an HTML5+TypeScript web application.

## Compiling and Running the Project

1. Install [node.js][nodejs] and [npm][npm].
2. Install TypeScript:

        > npm install -g typescript

3. Navigate to the project directory, and compile the TypeScript files:

        > tsc @files.txt

4. Open `index.html` in any modern browser (supports IE $\ge 10$ and the latest Firefox/Chrome).

[nodejs]: http://nodejs.org
[npm]: http://npmjs.org

## Using the Interpreter UI

The HTML5 UI is split into two panes. The right-side pane lists included test cases and provides a field for uploading `.pyc` files, and the left-side pane provides two tabs for output: the "Output" tab displays the interpreter's console output, while the "Bytecode" tab displays the bytecode of the `.pyc` file in a human-readable format. Clicking a test case filename or uploading a `.pyc` file will cause the interpreter to parse and execute the file.

The interpreter supports the `raw_input` builtin function, and may request user input via an HTML `<input type="text">` control displayed in the "Output" tab. The only test case that demonstrates this feature is `functions.pyc`.

Test cases are in the `pyc/` subdirectory of the project directory. All test cases are provided as both `.py` source files and `.pyc` binary files; to validate the output of the test cases, compare the "Output" tab of the UI with the ouput generated by executing the same test case's `.py` file in `python`.

# Implementation Details

## The Bytecode Parser

The `Python.Bin` module, contained in `bytecode.ts` and `pyc-parser.ts`, implements a Python 2.7._x_ bytecode parser. `bytecode.ts` specifies all of the opcodes, magic numbers, and data structures in marshalled Python code, and is thoroughly commented, including documentation from [Python's `dis` module][doc_dis] and [this page on Python marshalled types][doc_marshal].

A `Python.Bin.Parser` reads binary data from an JavaScript [DataView][dataview] object and converts it to a single marshalled _code object_ (`Python.Bin.CodeObject`), which itself contains several other marshalled data objects (`Python.Bin.Object`). If the parser executes without error, a human-readable representation of the marshalled code object will be printed to the "Bytecode" tab in the left pane of the UI.

All Python 2.7._x_ opcodes are documented and can be printed, although not all of them are implemented in the interpreter. Most of Python's marshalled data types are supported, but the `INT64`, `LONG`, and `UNICODE` types are not; attempting to load a `.pyc` file containing one of these data types will cause a parser error.

After parsing, the marshalled objects will be converted to "live" Python objects (`Python.PyObject`) via the unmarshaller (`unmarshaller.ts`).

[doc_dis]: https://docs.python.org/2/library/dis.html
[doc_marshal]: http://daeken.com/2010-02-20_Python_Marshal_Format.html
[dataview]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView

## The PyObject Hierarchy

All objects in the Python interpreter are instances of the `Python.PyObject` interface, which is loosely based on [the `PyObject` protocol][cpython_pyobject] in [Python's C API][cpython_api]. 

The interpreter uses a pure-object-oriented approach: everything is 	a `PyObject`, and every operation is a method---even primitive operations like basic math. This OO approach is strictly based on [Python's data model][datamodel]. Only a few special cases (`__repr__` and `__str__` for strings, `__call__` for functions) are implemented in a way that isn't accessible as a method call, and this was only done to avoid infinite recursion. Several basic, commonly-used methods on primitive types (including most operators) were implemented, but many have been omitted; an exhaustive implementation of Python's standard library is beyond the scope of this project.

Every `PyObject` has a type (`Python.PyTypeObject`), even type objects themselves, whose type is `Python.Types.TypeType`. Every type has a `__dict__`, which contains methods that can be called on instances of the type, either directly with a `self` argument (via `PyObject.callMethod()`), or by getting the method object as an attribute of an instance, then calling it with a normal argument list. Function calls support `*args`, `**kwargs`, and named arguments, although built-in methods only support fixed argument counts.

The interpreter does not support user-defined classes, but it defines the following built-in types in the following files:

* `PyObject.ts`: `object`, `type`, `dictproxy`, `method_descriptor`, `builtin_function_or_method`
* `PyNumbers.ts`: `int`, `bool`, `float`, `complex`
* `PyConstants.ts`: `None`, `Ellipsis`, `NotImplemented`
* `PyString.ts`: `str`
* `PySequences.ts`: `tuple`, `list`, `set`, `frozenset`
* `PyDict.ts`: `dict`
* `PyCodeObject.ts`: `code`, `function`
* `PyExceptions.ts`: Most of the [built-in exception types][builtin_exceptions]

[cpython_pyobject]: https://docs.python.org/2/c-api/object.html
[cpython_api]: https://docs.python.org/2/c-api/
[datamodel]: https://docs.python.org/2/reference/datamodel.html
[builtin_exceptions]: https://docs.python.org/2/library/exceptions.html

## The Interpreter

The interpreter (`interpreter.ts`) attempts to model the CPython interpreter as closely as possible. It is a stack machine, with three stacks:

* The _local stack_, which contains variables being used in the current block.
* The _block stack_, which contains blocks (loops, `try`/`except`/`finally`), each of which has its own local stack. `break`, `continue`, `return`, and exceptions may cause the interpreter to unwind this stack, pausing at any `finally` blocks to perform cleanup.
* The _code stack_, which contains code objects; a new code object is pushed whenever a function is called, and popped when a function returns. Each code object has its own block stack.

It supports only a limited subset of Python 2.7._x_ opcodes; the missing opcodes include, but are not limited to:

* `DUP_TOPX`
* `UNPACK_SEQUENCE`
* `YIELD_VALUE`
* `RAISE_VARARGS`
* `MAKE_CLOSURE` and `LOAD_CLOSURE` (because of this, functions that reference variables outside their own scopes don't work)
* Anything related to imports
* Anything related to the `with` statement
* `BUILD_CLASS` and a few other opcodes used for class creation
* The special print opcodes `PRINT_EXPR`, `PRINT_ITEM_TO`,  and `PRINT_NEWLINE_TO`
* The special call opcodes `CALL_FUNCTION_VAR`, `CALL_FUNCTION_KW`, and `CALL_FUNCTION_VAR_KW`

Although most of the interpreter's functionality could be derived from documentation alone, I ended up needing to reference [the CPython source code][ceval_src] to determine exactly how exceptions and `END_FINALLY` worked; the `dis` documentation for this is [not exactly comprehensive][end_finally]. Raising an exception pushes three objects onto the stack (exception, message, traceback), and entering a `finally` block will either push these three objects (if an exception caused the stack to unwind) or an integer called a "`WHY` value" (if something else cause the stack to unwind). `END_FINALLY` may consume either 1 or 3 objects from the stack depending on what it encounters. *None of this is documented.* Ultimately, I implemented `finally` blocks somewhat differently from CPython: `finally` recursively calls `Interpreter.exec()`, which returns when it encounters `END_FINALLY`, ignoring a `WHY` value if one exists.

[ceval_src]: https://github.com/python-git/python/blob/master/Python/ceval.c
[end_finally]: https://docs.python.org/2/library/dis.html#opcode-END_FINALLY

# Results and Observations

The interpreter manages to run a limited set of test cases with perfect accuracy. It undoubtedly still has some bugs; I didn't test it as thoroughly as I would have liked to.

I would have liked to include imports, classes, closures, and perhaps some standard library files, but there wasn't time. Even with its limited scope, support for numbers, strings, collections, flow control, exceptions, `print`, and `raw_input` is enough for this interpreter to run useful programs. With some work, this could easily become a full implementation of Python in the browser. 
